"use strict";(self.webpackChunketebase_docs=self.webpackChunketebase_docs||[]).push([[538],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return d}});var n=a(7294);function c(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){c(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,c=function(e,t){if(null==e)return{};var a,n,c={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(c[a]=e[a]);return c}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(c[a]=e[a])}return c}var i=n.createContext({}),s=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=s(e.components);return n.createElement(i.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,c=e.mdxType,o=e.originalType,i=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=s(a),d=c,h=m["".concat(i,".").concat(d)]||m[d]||b[d]||o;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function d(e,t){var a=arguments,c=t&&t.mdxType;if("string"==typeof e||c){var o=a.length,l=new Array(o);l[0]=m;var r={};for(var i in t)hasOwnProperty.call(t,i)&&(r[i]=t[i]);r.originalType=e,r.mdxType="string"==typeof e?e:c,l[1]=r;for(var s=2;s<o;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},8215:function(e,t,a){a.d(t,{Z:function(){return c}});var n=a(7294);function c(e){var t=e.children,a=e.hidden,c=e.className;return n.createElement("div",{role:"tabpanel",hidden:a,className:c},t)}},3709:function(e,t,a){a.d(t,{Z:function(){return b}});var n=a(7294),c=a(7462),o=a(2389),l=a(5979),r=a(6010),i="tabItem_LplD";function s(e){var t,a,o,s=e.lazy,u=e.block,b=e.defaultValue,m=e.values,d=e.groupId,h=e.className,p=n.Children.map(e.children,(function(e){if((0,n.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=m?m:p.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),_=(0,l.lx)(v,(function(e,t){return e.value===t.value}));if(_.length>0)throw new Error('Docusaurus error: Duplicate values "'+_.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var g=null===b?b:null!=(t=null!=b?b:null==(a=p.find((function(e){return e.props.default})))?void 0:a.props.value)?t:null==(o=p[0])?void 0:o.props.value;if(null!==g&&!v.some((function(e){return e.value===g})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+g+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var k=(0,l.UB)(),y=k.tabGroupChoices,f=k.setTabGroupChoices,j=(0,n.useState)(g),T=j[0],w=j[1],N=[],C=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=d){var A=y[d];null!=A&&A!==T&&v.some((function(e){return e.value===A}))&&w(A)}var E=function(e){var t=e.currentTarget,a=N.indexOf(t),n=v[a].value;n!==T&&(C(t),w(n),null!=d&&f(d,n))},B=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n=N.indexOf(e.currentTarget)+1;a=N[n]||N[0];break;case"ArrowLeft":var c=N.indexOf(e.currentTarget)-1;a=N[c]||N[N.length-1]}null==(t=a)||t.focus()};return n.createElement("div",{className:"tabs-container"},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":u},h)},v.map((function(e){var t=e.value,a=e.label,o=e.attributes;return n.createElement("li",(0,c.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:function(e){return N.push(e)},onKeyDown:B,onFocus:E,onClick:E},o,{className:(0,r.Z)("tabs__item",i,null==o?void 0:o.className,{"tabs__item--active":T===t})}),null!=a?a:t)}))),s?(0,n.cloneElement)(p.filter((function(e){return e.props.value===T}))[0],{className:"margin-vert--md"}):n.createElement("div",{className:"margin-vert--md"},p.map((function(e,t){return(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==T})}))))}function u(e){var t=(0,o.Z)();return n.createElement(s,(0,c.Z)({key:String(t)},e))}function b(e){var t=e.children;return n.createElement(u,{defaultValue:"js",groupId:"programming-language",values:[{label:"JavaScript",value:"js"},{label:"Python",value:"py"},{label:"Java",value:"java"},{label:"Kotlin",value:"kt"},{label:"C/C++",value:"c"},{label:"Rust",value:"rs"}]},t)}},2254:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return p},frontMatter:function(){return s},metadata:function(){return b},toc:function(){return d}});var n=a(7462),c=a(3366),o=(a(7294),a(3905)),l=a(3709),r=a(8215),i=["components"],s={title:"Local Cache"},u=void 0,b={unversionedId:"guides/local_cache",id:"guides/local_cache",title:"Local Cache",description:"At this point you should already know how to create, edit, list and delete data from Etebase.",source:"@site/docs/guides/local_cache.mdx",sourceDirName:"guides",slug:"/guides/local_cache",permalink:"/guides/local_cache",editUrl:"https://github.com/etesync/etebase-docs/edit/master/docs/guides/local_cache.mdx",tags:[],version:"current",frontMatter:{title:"Local Cache"},sidebar:"someSidebar",previous:{title:"Revision history",permalink:"/guides/revisions"},next:{title:"Utilities",permalink:"/api/utilities"}},m={},d=[{value:"Saving and loading collections",id:"saving-and-loading-collections",level:2},{value:"As Base64 encoded string",id:"as-base64-encoded-string",level:3},{value:"Saving and loading items",id:"saving-and-loading-items",level:2},{value:"As Base64 encoded string",id:"as-base64-encoded-string-1",level:3}],h={toc:d};function p(e){var t=e.components,a=(0,c.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"At this point you should already know how to create, edit, list and delete data from Etebase.\nHowever, as you may have noticed, in order to edit Etebase collections and items, you need to have them objects themselves to work with. Something you don't always have."),(0,o.kt)("p",null,"For example, to edit a collection's content you will call ",(0,o.kt)("inlineCode",{parentName:"p"},"setContent")," on an existing collection object.\nThis is fine if you already have the collection object, but what if you just started the app and don't have a collection object already?\nYou could just fetch the object each time before changing it, though it's both inefficient and in many cases incorrect."),(0,o.kt)("p",null,"The correct solution to this problem is to be able to save the objects to a local cache and load them afterwards, which is what this section is about."),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Cache objects are encrypted")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Cache objects are encrypted so you can store them locally without worrying."))),(0,o.kt)("p",null,"Storing and loading from cache is quite easy and is almost exactly the same for collections and items. The cache objects are just binary blobs, though if you require them to be valid strings you can convert them using the ",(0,o.kt)("a",{parentName:"p",href:"../api/utilities#base64"},"Base64 utilitis")," as shown below."),(0,o.kt)("h2",{id:"saving-and-loading-collections"},"Saving and loading collections"),(0,o.kt)(l.Z,{mdxType:"CodeTabs"},(0,o.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// Create a collection\nconst collection = await collectionManager.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nconst cacheBlob = collectionManager.cacheSave(collection);\n\n// Later on we can load the object back\nconst collection = collectionManager.cacheLoad(cacheBlob);\n// And use it like any other object:\nawait collection.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"py",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# Create a collection\ncollection = col_mgr.create(...)\n\n# The cache blob is just a bytes object that can be saved for later use\ncache_blob = col_mgr.cache_save(collection)\n\n# Later on we can load the object back\ncollection = col_mgr.cache_load(cache_blob)\n# And use it like any other object:\ncollection.content = b"New content"\n'))),(0,o.kt)(r.Z,{value:"java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// Create a collection\nCollection collection = colMgr.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nbyte[] cacheBlob = colMgr.cacheSave(collection);\n\n// Later on we can load the object back\nCollection collection = colMgr.cacheLoad(cacheBlob);\n// And use it like any other object:\ncollection.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"kt",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Create a collection\nval collection = colMgr.create(...)\n\n// The cache blob is just a Uint8Array that can be saved for later use\nval cacheBlob = colMgr.cacheSave(collection)\n\n// Later on we can load the object back\nval collection = colMgr.cacheLoad(cacheBlob)\n// And use it like any other object:\ncollection.content = "New content"\n'))),(0,o.kt)(r.Z,{value:"c",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"// Create a collection\nEtebaseCollection *col = etebase_collection_manager_create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nuintptr_t cache_size;\nvoid *cache_blob = etebase_collection_manager_cache_save(col_mgr, col, &cache_size);\n\n// Later on we can load the object back\nEtebaseCollection *col = etebase_collection_manager_cache_load(col_mgr, cache_blob, cache_size)\n// And use it like any other object:\netebase_collection_get_uid(col);\n\nfree(cache_blob);\n"))),(0,o.kt)(r.Z,{value:"rs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Create a collection\nlet collection = collection_manager.create(...)?;\n\n// The cache blob is just a Uint8Array that can be saved for later use\nlet cache_blob = collection_manager.cache_save(&collection)?;\n\n// Later on we can load the object back\nlet mut collection = collection_manager.cache_load(&cache_blob)?;\n// And use it like any other object:\ncollection.set_content(b"New content")?;\n')))),(0,o.kt)("h3",{id:"as-base64-encoded-string"},"As Base64 encoded string"),(0,o.kt)(l.Z,{mdxType:"CodeTabs"},(0,o.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// Create a collection\nconst collection = await collectionManager.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nconst cacheB64 = Etebase.toBase64(collectionManager.cacheSave(collection));\n\n// Later on we can load the object back\nconst collection = collectionManager.cacheLoad(Etebase.fromBase64(cacheB64));\n// And use it like any other object:\nawait collection.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"py",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from etebase import Base64Url\n\n# Create a collection\ncollection = col_mgr.create(...)\n\n# The cache blob is just a bytes object that can be saved for later use\ncache_b64 = Base64Url.to_base64(col_mgr.cache_save(collection))\n\n# Later on we can load the object back\ncollection = col_mgr.cache_load(Base64Url.from_base64(cache_blob))\n# And use it like any other object:\ncollection.content = b"New content"\n'))),(0,o.kt)(r.Z,{value:"java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// Create a collection\nCollection collection = colMgr.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nString cacheB64 = Utils.toBase64(colMgr.cacheSave(collection));\n\n// Later on we can load the object back\nCollection collection = colMgr.cacheLoad(Utils.fromBase64(cacheB64));\n// And use it like any other object:\ncollection.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"kt",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Create a collection\nval collection = colMgr.create(...)\n\n// The cache blob is just a Uint8Array that can be saved for later use\nval cacheB64 = Utils.toBase64(colMgr.cacheSave(collection))\n\n// Later on we can load the object back\nval collection = colMgr.cacheLoad(Utils.fromBase64(cacheB64))\n// And use it like any other object:\ncollection.content = "New content"\n'))),(0,o.kt)(r.Z,{value:"c",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"// Create a collection\nEtebaseCollection *col = etebase_collection_manager_create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nuintptr_t cache_size;\nvoid *cache_blob = etebase_collection_manager_cache_save(col_mgr, col, &cache_size);\nchar cache_b64[ETEBASE_UTILS_TO_BASE64_MAX_LEN(cache_size)];\netebase_utils_to_base64(cache_blob, cache_size, cache_b64, sizeof(cache_b64));\n\n// Later on we can load the object back\nchar decoded[ETEBASE_UTILS_FROM_BASE64_MAX_LEN(strlen(cache_b64))];\nuintptr_t decoded_len = 0;\netebase_utils_from_base64(cache_b64, decoded, sizeof(decoded), &decoded_len);\nEtebaseCollection *col = etebase_collection_manager_cache_load(col_mgr, decoded, decoded_len)\n// And use it like any other object:\netebase_collection_get_uid(col);\n\nfree(cache_blob);\n"))),(0,o.kt)(r.Z,{value:"rs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Create a collection\nlet collection = collection_manager.create(...)?;\n\n// The cache blob is just a Uint8Array that can be saved for later use\nlet cache_b64 = utils::to_base64(&collection_manager.cache_save(&collection)?)?;\n\n// Later on we can load the object back\nlet mut collection = collection_manager.cache_load(&utils::from_base64(&cache_b64)?)?;\n// And use it like any other object:\ncollection.set_content(b"New content")?;\n')))),(0,o.kt)("h2",{id:"saving-and-loading-items"},"Saving and loading items"),(0,o.kt)(l.Z,{mdxType:"CodeTabs"},(0,o.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// Create an item\nconst item = await itemManager.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nconst cacheBlob = itemManager.cacheSave(item);\n\n// Later on we can load the object back\nconst item = itemManager.cacheLoad(cacheBlob);\n// And use it like any other object:\nawait item.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"py",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'# Create an item\nitem = item_mgr.create(...)\n\n# The cache blob is just a bytes object that can be saved for later use\ncache_blob = item_mgr.cache_save(item)\n\n# Later on we can load the object back\nitem = item_mgr.cache_load(cache_blob)\n# And use it like any other object:\nitem.content = b"New content"\n'))),(0,o.kt)(r.Z,{value:"java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// Create an item\nItem item = itemManager.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nbyte[] cacheBlob = itemManager.cacheSave(item);\n\n// Later on we can load the object back\nItem item = itemManager.cacheLoad(cacheBlob);\n// And use it like any other object:\nitem.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"kt",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Create an item\nval item = itemManager.create(...)\n\n// The cache blob is just a Uint8Array that can be saved for later use\nval cacheBlob = itemManager.cacheSave(item)\n\n// Later on we can load the object back\nval item = itemManager.cacheLoad(cacheBlob)\n// And use it like any other object:\nitem.content = "New content"\n'))),(0,o.kt)(r.Z,{value:"c",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"// Create a item\nEtebaseItem *item = etebase_item_manager_create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nuintptr_t cache_size;\nvoid *cache_blob = etebase_item_manager_cache_save(item_mgr, item, &cache_size);\n\n// Later on we can load the object back\nEtebaseItem *item = etebase_item_manager_cache_load(item_mgr, cache_blob, cache_size)\n// And use it like any other object:\netebase_item_get_uid(item);\n\nfree(cache_blob);\n"))),(0,o.kt)(r.Z,{value:"rs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Create an item\nlet item = item_manager.create(...)?;\n\n// The cache blob is just a Uint8Array that can be saved for later use\nlet cache_blob = item_manager.cache_save(&item)?;\n\n// Later on we can load the object back\nlet mut item = item_manager.cache_load(&cache_blob)?;\n// And use it like any other object:\nitem.set_content(b"New content")?;\n')))),(0,o.kt)("h3",{id:"as-base64-encoded-string-1"},"As Base64 encoded string"),(0,o.kt)(l.Z,{mdxType:"CodeTabs"},(0,o.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// Create an item\nconst item = await itemManager.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nconst cacheB64 = Etebase.toBase64(itemManager.cacheSave(item));\n\n// Later on we can load the object back\nconst item = itemManager.cacheLoad(Etebase.fromBase64(cacheB64));\n// And use it like any other object:\nawait item.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"py",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from etebase import Base64Url\n\n# Create an item\nitem = item_mgr.create(...)\n\n# The cache blob is just a bytes object that can be saved for later use\ncache_b64 = Base64Url.to_base64(item_mgr.cache_save(item))\n\n# Later on we can load the object back\nitem = item_mgr.cache_load(Base64Url.from_base64(cache_blob))\n# And use it like any other object:\nitem.content = b"New content"\n'))),(0,o.kt)(r.Z,{value:"java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// Create an item\nItem item = itemManager.create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nString cacheB64 = Utils.toBase64(itemManager.cacheSave(item));\n\n// Later on we can load the object back\nItem item = itemManager.cacheLoad(Utils.fromBase64(cacheB64));\n// And use it like any other object:\nitem.setContent("New content");\n'))),(0,o.kt)(r.Z,{value:"kt",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Create an item\nval item = itemManager.create(...)\n\n// The cache blob is just a Uint8Array that can be saved for later use\nval cacheB64 = Utils.toBase64(itemManager.cacheSave(item))\n\n// Later on we can load the object back\nval item = itemManager.cacheLoad(Utils.fromBase64(cacheB64))\n// And use it like any other object:\nitem.content = "New content"\n'))),(0,o.kt)(r.Z,{value:"c",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c"},"// Create a item\nEtebaseItem *item = etebase_item_manager_create(...);\n\n// The cache blob is just a Uint8Array that can be saved for later use\nuintptr_t cache_size;\nvoid *cache_blob = etebase_item_manager_cache_save(item_mgr, item, &cache_size);\nchar cache_b64[ETEBASE_UTILS_TO_BASE64_MAX_LEN(cache_size)];\netebase_utils_to_base64(cache_blob, cache_size, cache_b64, sizeof(cache_b64));\n\n// Later on we can load the object back\nchar decoded[ETEBASE_UTILS_FROM_BASE64_MAX_LEN(strlen(cache_b64))];\nuintptr_t decoded_len = 0;\netebase_utils_from_base64(cache_b64, decoded, sizeof(decoded), &decoded_len);\nEtebaseItem *item = etebase_item_manager_cache_load(item_mgr, decoded, decoded_len)\n// And use it like any other object:\netebase_item_get_uid(item);\n\nfree(cache_blob);\n"))),(0,o.kt)(r.Z,{value:"rs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Create an item\nlet item = item_manager.create(...)?;\n\n// The cache blob is just a Uint8Array that can be saved for later use\nlet cache_b64 = utils::to_base64(&item_manager.cache_save(&item)?)?;\n\n// Later on we can load the object back\nlet mut item = item_manager.cache_load(&utils::from_base64(&cache_b64)?)?;\n// And use it like any other object:\nitem.set_content(b"New content")?;\n')))))}p.isMDXComponent=!0}}]);