"use strict";(self.webpackChunketebase_docs=self.webpackChunketebase_docs||[]).push([[803],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var o=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,l=function(e,t){if(null==e)return{};var n,o,l={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=o.createContext({}),r=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},m=function(e){var t=r(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),p=r(n),u=l,g=p["".concat(s,".").concat(u)]||p[u]||d[u]||a;return n?o.createElement(g,c(c({ref:t},m),{},{components:n})):o.createElement(g,c({ref:t},m))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=n.length,c=new Array(a);c[0]=p;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,c[1]=i;for(var r=2;r<a;r++)c[r]=n[r];return o.createElement.apply(null,c)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8215:function(e,t,n){n.d(t,{Z:function(){return l}});var o=n(7294);function l(e){var t=e.children,n=e.hidden,l=e.className;return o.createElement("div",{role:"tabpanel",hidden:n,className:l},t)}},3709:function(e,t,n){n.d(t,{Z:function(){return d}});var o=n(7294),l=n(7462),a=n(2389),c=n(5979),i=n(6010),s="tabItem_LplD";function r(e){var t,n,a,r=e.lazy,m=e.block,d=e.defaultValue,p=e.values,u=e.groupId,g=e.className,_=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=p?p:_.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,c.lx)(k,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===d?d:null!=(t=null!=d?d:null==(n=_.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(a=_[0])?void 0:a.props.value;if(null!==y&&!k.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+k.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var h=(0,c.UB)(),v=h.tabGroupChoices,f=h.setTabGroupChoices,T=(0,o.useState)(y),N=T[0],w=T[1],M=[],C=(0,c.o5)().blockElementScrollPositionUntilNextRender;if(null!=u){var I=v[u];null!=I&&I!==N&&k.some((function(e){return e.value===I}))&&w(I)}var x=function(e){var t=e.currentTarget,n=M.indexOf(t),o=k[n].value;o!==N&&(C(t),w(o),null!=u&&f(u,o))},O=function(e){var t,n=null;switch(e.key){case"ArrowRight":var o=M.indexOf(e.currentTarget)+1;n=M[o]||M[0];break;case"ArrowLeft":var l=M.indexOf(e.currentTarget)-1;n=M[l]||M[M.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":m},g)},k.map((function(e){var t=e.value,n=e.label,a=e.attributes;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:function(e){return M.push(e)},onKeyDown:O,onFocus:x,onClick:x},a,{className:(0,i.Z)("tabs__item",s,null==a?void 0:a.className,{"tabs__item--active":N===t})}),null!=n?n:t)}))),r?(0,o.cloneElement)(_.filter((function(e){return e.props.value===N}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},_.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==N})}))))}function m(e){var t=(0,a.Z)();return o.createElement(r,(0,l.Z)({key:String(t)},e))}function d(e){var t=e.children;return o.createElement(m,{defaultValue:"js",groupId:"programming-language",values:[{label:"JavaScript",value:"js"},{label:"Python",value:"py"},{label:"Java",value:"java"},{label:"Kotlin",value:"kt"},{label:"C/C++",value:"c"},{label:"Rust",value:"rs"}]},t)}},6169:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return m},default:function(){return _},frontMatter:function(){return r},metadata:function(){return d},toc:function(){return u}});var o=n(7462),l=n(3366),a=(n(7294),n(3905)),c=n(3709),i=n(8215),s=["components"],r={title:"Using Collections"},m=void 0,d={unversionedId:"guides/using_collections",id:"guides/using_collections",title:"Using Collections",description:"This section assumes you have already read the overview and understand what collections are and what they are for.",source:"@site/docs/guides/using_collections.mdx",sourceDirName:"guides",slug:"/guides/using_collections",permalink:"/guides/using_collections",editUrl:"https://github.com/etesync/etebase-docs/edit/master/docs/guides/using_collections.mdx",tags:[],version:"current",frontMatter:{title:"Using Collections"},sidebar:"someSidebar",previous:{title:"Authentication",permalink:"/guides/basic_authentication"},next:{title:"Using Items",permalink:"/guides/using_items"}},p={},u=[{value:"Creating collections",id:"creating-collections",level:2},{value:"Fetching collections",id:"fetching-collections",level:2},{value:"Simple fetch",id:"simple-fetch",level:3},{value:"Only fetch recent changes",id:"only-fetch-recent-changes",level:3},{value:"Fetch in chunks",id:"fetch-in-chunks",level:3},{value:"Fetch by <code>uid</code>",id:"fetch-by-uid",level:3},{value:"Removed memberships",id:"removed-memberships",level:3},{value:"Modifying and deleting collections",id:"modifying-and-deleting-collections",level:2},{value:"Advanced uploads and transactions",id:"advanced-uploads-and-transactions",level:2},{value:"Transactions",id:"transactions",level:3},{value:"Using <code>stoken</code>",id:"using-stoken",level:3},{value:"Binary content",id:"binary-content",level:2}],g={toc:u};function _(e){var t=e.components,n=(0,l.Z)(e,s);return(0,a.kt)("wrapper",(0,o.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This section assumes you have already read ",(0,a.kt)("a",{parentName:"p",href:"../overview"},"the overview")," and understand what collections are and what they are for."),(0,a.kt)("h2",{id:"creating-collections"},"Creating collections"),(0,a.kt)("p",null,"When creating collections, you need to pass the ",(0,a.kt)("a",{parentName:"p",href:"../overview#collection-type"},"collection type")," as the first parameter, followed by the ",(0,a.kt)("a",{parentName:"p",href:"../overview#metadata-1"},"metadata")," and the content."),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const etebase = await Etebase.Account.login("username", "password");\nconst collectionManager = etebase.getCollectionManager();\n\n// Create, encrypt and upload a new collection\nconst collection = await collectionManager.create("cyberdyne.calendar",\n  {\n    name: "Holidays",\n    description: "My holiday calendar",\n    color: "#23aabbff",\n  },\n  "" // Empty content\n);\nawait collectionManager.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from etebase import Client, Account\n\nclient = Client("client-name")\netebase = Account.login(client, "username", "password")\n\ncol_mgr = etebase.get_collection_manager()\n\n# Create, encrypt and upload a new collection\ncollection = col_mgr.create("cyberdyne.calendar",\n    {\n        "name": "Holidays",\n        "description": "My holiday calendar",\n        "color": "#23aabbff",\n    },\n    b"" # Empty content\n)\ncol_mgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'import com.etebase.client.*;\n\nClient client = Client.create(httpClient, null);\nAccount etebase = Account.login(client, "username", "password");\n\nCollectionManager colMgr = etebase.getCollectionManager();\n\n// Create, encrypt and upload a new collection\nItemMetadata collectionMetadata = new ItemMetadata()\ncollectionMetadata.setName("Holidays");\ncollectionMetadata.setDescription("My holiday calendar");\ncollectionMetadata.setColor("#23aabbff");\nCollection collection = colMgr.create("cyberdyne.calendar", collectionMetadata, "");\n\ncolMgr.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'import com.etebase.client.*\n\nval client = Client.create(httpClient, null)\nval etebase = Account.login(client, "username", "password")\n\nval colMgr = etebase.collectionManager\n\n// Create, encrypt and upload a new collection\nval collectionMetadata = ItemMetadata()\ncollectionMetadata.name = "Holidays"\ncollectionMetadata.description = "My holiday calendar"\ncollectionMetadata.color = "#23aabbff"\nval collection = colMgr.create("cyberdyne.calendar", collectionMetadata, "")\n\ncolMgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'const char *server_url = etebase_get_default_server_url();\nEtebaseClient *client = etebase_client_new("client-name", server_url);\nEtebaseAccount *etebase = etebase_account_login(client, "username", "password");\n\n// Create, encrypt and upload a new collection\nEtebaseCollectionManager *col_mgr = etebase_account_get_collection_manager(etebase);\nEtebaseItemMetadata *col_meta = etebase_collection_metadata_new();\netebase_collection_metadata_set_name(col_meta, "Holidays");\netebase_collection_metadata_set_description(col_meta, "My holiday calendar");\netebase_collection_metadata_set_color(col_meta, "#23aabbff");\nEtebaseCollection *col = etebase_collection_manager_create("cyberdyne.calendar", col_mgr, col_meta, "", 0);\netebase_collection_metadata_destroy(col_meta);\n\netebase_collection_manager_upload(col_mgr, col, NULL);\n\n// Cleanup\netebase_collection_destroy(col);\netebase_collection_manager_destroy(col_mgr);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use etebase::{Account, Client, ItemMetadata};\n\nlet client = Client::new(..., server_url)?;\nlet etebase = Account::login(client, "username", "password")?;\n\nlet collection_manager = etebase.collection_manager()?;\n\n// Create, encrypt and upload a new collection\nlet collection = collection_manager.create(\n    "cyberdyne.calendar",\n    ItemMetadata::new()\n        .set_name(Some("Holidays"))\n        .set_description(Some("My holiday calendar"))\n        .set_color(Some("#23aabbff")),\n    &[], // Empty content\n)?;\ncollection_manager.upload(&collection, None)?;\n')))),(0,a.kt)("h2",{id:"fetching-collections"},"Fetching collections"),(0,a.kt)("p",null,"Fetching the list of collections is easy, and is the first step in any Etebase application, because collections contain the data."),(0,a.kt)("h3",{id:"simple-fetch"},"Simple fetch"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const etebase = await Etebase.Account.login("username", "password");\nconst collectionManager = etebase.getCollectionManager();\n\nconst collections = await collectionManager.list("cyberdyne.calendar");\n/*\nCollections:\n{\n  data: Etebase.Collection[], // Returned array of collections\n  stoken: string, // The sync token for this fetch\n  ... // More fields we\'ll cover later\n}\n*/\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'etebase = Account.login(...)\n\ncol_mgr = etebase.get_collection_manager()\ncollections = col_mgr.list("cyberdyne.calendar")\n# {\n#   data: iter(etebase.Collection),  # Returned iterator of collections\n#   stoken: string,  # The sync token for this fetch\n#   ...  # More fields we\'ll cover later\n# }\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'import com.etebase.client.*;\n\nAccount etebase = Account.login(...);\n\nCollectionManager colMgr = etebase.getCollectionManager();\nCollectionListResponse collections = colMgr.list("cyberdyne.calendar");\n/*\nCollections:\n{\n  data: Collection[], // Returned array of collections\n  stoken: string, // The sync token for this fetch\n  ... // More fields we\'ll cover later\n}\n*/\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'import com.etebase.client.*\n\nval etebase = Account.login(...)\n\nval colMgr = etebase.collectionManager\nval collections = colMgr.list("cyberdyne.calendar")\n/*\nCollections:\n{\n  data: Collection[], // Returned array of collections\n  stoken: string, // The sync token for this fetch\n  ... // More fields we\'ll cover later\n}\n*/\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'EtebaseAccount *etebase = etebase_account_login(...);\n\nEtebaseCollectionManager *col_mgr = etebase_account_get_collection_manager(etebase);\nEtebaseCollectionListResponse *col_list = etebase_collection_manager_list(col_mgr, "cyberdyne.calendar", NULL);\n/*\nCollections:\n{\n  etebase_collection_list_response_get_data(): EtebaseCollection[] // Returned array of collections\n  etebase_collection_list_response_get_stoken(): const char * // The sync token for this fetch\n  ... // More fields we\'ll cover later\n}\n*/\n\n// Cleanup\netebase_collection_list_response_destroy(col_list);\netebase_collection_manager_destroy(col_mgr);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use etebase::{Account};\n\nlet etebase = Account::login(...)?;\n\nlet collection_manager = etebase.collection_manager()?;\n\nlet collections = collection_manager.list("cyberdyne.calendar", None)?;\n/*\ncollections: CollectionListResponse<Collection> {\n  data: Vec<Collection>, // Returned array of collections\n  stoken: Option<String>, // The sync token for this fetch\n  ... // More fields we\'ll cover later\n}\n*/\n')))),(0,a.kt)("p",null,"The number of returned collections is limited by default, and you can control this limit by passing a different limit parameter as we'll see in the next example:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const collections = await collectionManager.list("cyberdyne.calendar", { limit: 50 });\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'from etebase import FetchOptions\n\ncollections = col_mgr.list("cyberdyne.calendar", FetchOptions().limit(50))\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'import com.etebase.client.*;\n\nCollectionListResponse collections = colMgr.list("cyberdyne.calendar", new FetchOptions().limit(50));\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'import com.etebase.client.*\n\nval collections = colMgr.list("cyberdyne.calendar", FetchOptions().limit(50))\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'EtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_limit(fetch_options, 50);\nEtebaseCollectionListResponse *col_list = etebase_collection_manager_list(col_mgr, "cyberdyne.calendar", fetch_options);\n\n// Cleanup\netebase_fetch_options_destroy(fetch_options);\netebase_collection_list_response_destroy(col_list);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let collections =\n    collection_manager.list("cyberdyne.calendar", Some(&FetchOptions::new().limit(50)))?;\n')))),(0,a.kt)("p",null,"You can also fetch multiple collection types at the same time:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const collections = await collectionManager.list(["cyberdyne.calendar", "cyberdyne.tasks"]);\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'collections = col_mgr.list(["cyberdyne.calendar", "cyberdyne.tasks"])\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'CollectionListResponse collections = colMgr.list(new String[] {"cyberdyne.calendar", "cyberdyne.tasks"});\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val collections = colMgr.list(arrayOf("cyberdyne.calendar", "cyberdyne.tasks"))\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'const char *col_types[] = {"cyberdyne.calendar", "cyberdyne.tasks"};\n\nEtebaseCollectionListResponse *col_list = etebase_collection_manager_list_multi(\n    col_mgr, col_types, ETEBASE_UTILS_C_ARRAY_LEN(col_types), NULL);\n\n// Cleanup\netebase_collection_list_response_destroy(col_list);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let collections = collection_manager.list_multi(\n    vec!["cyberdyne.calendar", "cyberdyne.tasks"].into_iter(),\n    None,\n)?;\n')))),(0,a.kt)("h3",{id:"only-fetch-recent-changes"},"Only fetch recent changes"),(0,a.kt)("p",null,"We can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"stoken")," we have gotten in previous fetches to only return changed collections. A collection is considered changed if either it or any of its items have changed."),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const stoken = "..."; // An stoken we got previously e.g. collections.stoken\n\nconst collections = await collectionManager.list("cyberdyne.calendar", { stoken });\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'stoken = "..."  # An stoken we got previously e.g. collections.stoken\n\ncol_mgr = etebase.get_collection_manager()\ncollections = col_mgr.list("cyberdyne.calendar", FetchOptions().stoken(stoken))\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'String stoken = "..."; // An stoken we got previously e.g. collections.stoken\n\nCollectionManager colMgr = etebase.getCollectionManager();\nCollectionListResponse collections = colMgr.list("cyberdyne.calendar", new FetchOptions().stoken(stoken));\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val stoken = "..." // An stoken we got previously e.g. collections.stoken\n\nval colMgr = etebase.collectionManager\nval collections = colMgr.list("cyberdyne.calendar", FetchOptions().stoken(stoken))\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'const char *stoken = "..."; // An stoken we got previously e.g. collections.stoken\n\nEtebaseCollectionManager *col_mgr = etebase_account_get_collection_manager(etebase);\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nEtebaseCollectionListResponse *col_list = etebase_collection_manager_list(col_mgr, "cyberdyne.calendar", fetch_options);\n\n// Cleanup\netebase_fetch_options_destroy(fetch_options);\netebase_collection_list_response_destroy(col_list);\netebase_collection_manager_destroy(col_mgr);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let stoken = "..." // An stoken we got previously e.g. collections.stoken()\n\nlet collection_manager = etebase.collection_manager()?;\nlet collections = collection_manager.list(\n  "cyberdyne.calendar",\n  Some(&FetchOptions::new().stoken(Some(stoken)))\n)?;\n')))),(0,a.kt)("h3",{id:"fetch-in-chunks"},"Fetch in chunks"),(0,a.kt)("p",null,"We can use a combination of limit and stoken to fetch the changes in chunks rather than all at once. This is more resistant to spotty internet connections, and means we can show data to users faster."),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'let stoken = null;\nwhile (true) {\n  const collections = await collectionManager.list("cyberdyne.calendar", { stoken, limit: 30 });\n  stoken = collections.stoken;\n\n  processNewCollections(collections.data);\n\n  if (collections.done) {\n    break;\n  }\n}\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'stoken = None\ndone = False\nwhile not done:\n    collections = col_mgr.list("cyberdyne.calendar", FetchOptions().stoken(stoken).limit(30))\n    stoken = collections.stoken\n    done = collections.done\n\n    process_new_collections(collections.data)\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'String stoken = null;\nboolean done = false;\nwhile (!done) {\n    CollectionListResponse collections = colMgr.list("cyberdyne.calendar", new FetchOptions().stoken(stoken).limit(30));\n    stoken = collections.getStoken();\n    done = collections.isDone();\n\n    process_new_collections(collections.getData());\n}\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'var stoken: String? = null\nvar done = false\nwhile (!done) {\n    val collections = colMgr.list("cyberdyne.calendar", FetchOptions().stoken(stoken).limit(30))\n    stoken = collections.stoken\n    done = collections.isDone\n\n    process_new_collections(collections.data)\n}\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'char *stoken = NULL;\nbool done = 0;\nwhile (!done) {\n    EtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\n    etebase_fetch_options_set_stoken(fetch_options, stoken);\n    etebase_fetch_options_set_limit(fetch_options, 30);\n    EtebaseCollectionListResponse *col_list = etebase_collection_manager_list("cyberdyne.calendar", col_mgr, fetch_options);\n\n    if (stoken) {\n        free(stoken);\n    }\n    stoken = strdup(etebase_collection_list_response_get_stoken(col_list));\n    done = etebase_collection_list_response_is_done(col_list);\n\n    uintptr_t data_len = etebase_collection_list_response_get_data_length(col_list);\n    const EtebaseCollection *data[data_len];\n    fail_if(etebase_collection_list_response_get_data(col_list, data));\n\n    process_new_collections(data, data_len);\n\n    etebase_fetch_options_destroy(fetch_options);\n    etebase_collection_list_response_destroy(col_list);\n}\n\nif (stoken) {\n    free(stoken);\n}\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let mut stoken: Option<&str> = None;\nlet mut collections: CollectionListResponse<Collection>;\nloop {\n    collections = collection_manager.list(\n        "cyberdyne.calendar", \n        Some(&FetchOptions::new().stoken(stoken).limit(30))\n    )?;\n    stoken = collections.stoken();\n\n    process_new_collections(collections.data());\n    if collections.done() {\n        break\n    }\n}\n')))),(0,a.kt)("h3",{id:"fetch-by-uid"},"Fetch by ",(0,a.kt)("inlineCode",{parentName:"h3"},"uid")),(0,a.kt)("p",null,"Sometimes we don't care about getting the whole list of collections, and we are just interested in fetching one collection based on its ",(0,a.kt)("inlineCode",{parentName:"p"},"uid"),". We can do it like this:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const collection = await collectionManager.fetch(collectionUid);\n\n// Can optionally pass stoken to only return the collection if changed:\nconst collection = await collectionManager.fetch(collectionUid, { stoken });\n"))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"collection = col_mgr.fetch(collection_uid)\n\n# Can optionally pass stoken to only return the collection if changed:\ncollection = col_mgr.fetch(collection_uid, FetchOptions().stoken(stoken))\n"))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"Collection collection = colMgr.fetch(collectionUid);\n\n// Can optionally pass stoken to only return the collection if changed:\nCollection collection = colMgr.fetch(collectionUid, new FetchOptions().stoken(stoken));\n"))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"val collection = colMgr.fetch(collectionUid);\n\n// Can optionally pass stoken to only return the collection if changed:\nval collection = colMgr.fetch(collectionUid, FetchOptions().stoken(stoken))\n"))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"EtebaseCollection *col = etebase_collection_manager_fetch(col_mgr, col_uid, NULL);\n\n// Can optionally pass stoken to only return the collection if changed:\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nEtebaseCollection *col = etebase_collection_manager_fetch(col_mgr, col_uid, fetch_options);\netebase_fetch_options_destroy(fetch_options);\n"))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let collection = collection_manager.fetch(collection_uid, None)?;\n\n// Can optionally pass stoken to only return the collection if changed:\nlet collection = collection_manager.fetch(collection_uid, Some(&FetchOptions::new().stoken(stoken)))?;\n")))),(0,a.kt)("h3",{id:"removed-memberships"},"Removed memberships"),(0,a.kt)("p",null,"When a collection is deleted it will be marked as deleted and signed so clients can verify it was really deleted by the owner rather than forged by the server."),(0,a.kt)("p",null,"However, when a user loses access to a collection it's not marked as deleted. Instead, its ",(0,a.kt)("inlineCode",{parentName:"p"},"uid")," is returned in a special list. Here is how it looks:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const stoken = "..."; // An stoken we got previously\n\nconst collections = await collectionManager.list("cyberdyne.calendar", { stoken });\n\n// collections.removedMemberships is either undefined or a list of removed uids.\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'stoken = "..."  # An stoken we got previously e.g. collections.stoken\n\ncollections = col_mgr.list("cyberdyne.calendar", FetchOptions().stoken(stoken))\n\n# collections.removed_memberships is an iterator of removed uids\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'String stoken = "..."; // An stoken we got previously e.g. collections.stoken\n\nCollectionListResponse collections = colMgr.list("cyberdyne.calendar", new FetchOptions().stoken(stoken));\n\n// collections.removedMemberships is either empty or a list of removed uids.\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val stoken = "..." // An stoken we got previously e.g. collections.stoken\n\nval collections = colMgr.list("cyberdyne.calendar", FetchOptions().stoken(stoken))\n\n// collections.removedMemberships is either empty or a list of removed uids.\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'const char *stoken = "..."; // An stoken we got previously e.g. collections.stoken\n\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\nEtebaseCollectionListResponse *col_list = etebase_collection_manager_list(col_mgr, "cyberdyne.calendar", fetch_options);\netebase_fetch_options_destroy(fetch_options);\n\nuintptr_t removed_len = etebase_collection_list_response_get_removed_memberships_length(col_list);\nconst EtebaseRemovedCollection *removed[removed_len];\nfail_if(etebase_collection_list_response_get_removed_memberships(col_list, removed));\n// removed is either empty or a list of removed collections\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let stoken = "..."; // An stoken we got previously e.g. collections.stoken()\n\nlet collections = collection_manager.list("cyberdyne.calendar", Some(&FetchOptions::new().stoken(Some(stoken))))?;\n\n// collections.removed_memberships() is either None or a list of removed uids.\n')))),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note:")," because membership removals are not signed, it's good practice to show an indication to the user before removing the local copy."),(0,a.kt)("h2",{id:"modifying-and-deleting-collections"},"Modifying and deleting collections"),(0,a.kt)("p",null,"Modifying collections is easy, it's just a matter of changing them and uploading them."),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const meta = collection.getMeta();\ncollection.setMeta({ ...meta, name: "New name" });\n\nawait collectionManager.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'meta = collection.meta\nmeta["name"] = "New name"\ncollection.meta = meta\n\ncol_mgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'ItemMetadata collectionMeta = collection.getMeta();\ncollectionMeta.setName("Name");\ncollection.setMeta(collectionMeta);\n\ncolMgr.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val collectionMeta = collection.meta\ncollectionMeta.name = "Name"\ncollection.meta = collectionMeta\n\ncolMgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'EtebaseItemMetadata *col_meta = etebase_collection_get_meta(col);\netebase_collection_metadata_set_name(col_meta, "Name");\netebase_collection_set_meta(col, col_meta);\netebase_collection_metadata_destroy(col_meta);\n\netebase_collection_manager_upload(col_mgr, col, NULL);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let mut collection = collection_manager.fetch("collection_uid", None)?;\nlet mut collection_meta = collection.meta()?;\ncollection_meta.set_name("name");\ncollection.set_meta(&collection_meta)?;\ncollection_manager.upload(&collection, None)?;\n')))),(0,a.kt)("p",null,"Deleting is even easier:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"collection.delete();\n\nawait collectionManager.upload(collection);\n"))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"collection.delete()\n\ncol_mgr.upload(collection)\n"))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"collection.delete();\n\ncolMgr.upload(collection);\n"))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"collection.delete()\n\ncolMgr.upload(collection)\n"))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"etebase_collection_delete(col);\n\netebase_collection_manager_upload(col_mgr, col, NULL);\n"))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"collection.delete()?;\n\ncollection_manager.upload(&collection, None)?;\n")))),(0,a.kt)("h2",{id:"advanced-uploads-and-transactions"},"Advanced uploads and transactions"),(0,a.kt)("p",null,"In the examples above we always uploaded the collections in a way that overwrote whatever is on the server, regardless if it has changed since we last fetched it, or not. While this is fine in many cases, in some cases you want to prevent that in order to ensure the consistency of data."),(0,a.kt)("h3",{id:"transactions"},"Transactions"),(0,a.kt)("p",null,"The easiest way to ensure consistency is just to use transactions. Transactions make sure that what we think is the most recent version, really is, and will fail otherwise."),(0,a.kt)("p",null,"For example:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// -> On device A:\nconst collection = await collectionManager.fetch(collectionUid);\n\n\n// -> On device B:\nconst collection = await collectionManager.fetch(collectionUid);\nconst meta = collection.getMeta();\ncollection.setMeta({ ...meta, name: "New name" });\n\nawait collectionManager.upload(collection);\n\n\n// -> On device A (using the previously saved collection)\nconst meta = collection.getMeta();\ncollection.setMeta({ ...meta, name: "Another name" });\n\n// Will fail\nawait collectionManager.transaction(collection);\n// Will succeed\nawait collectionManager.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# -> On device A:\ncollection = col_mgr.fetch(collection_uid)\n\n\n# -> On device B:\ncollection = col_mgr.fetch(collection_uid)\nmeta = collection.meta\nmeta["name"] = "New name"\ncollection.meta = meta\n\ncol_mgr.upload(collection)\n\n\n# -> On device A (using the previously saved collection)\nmeta = collection.meta\nmeta["name"] = "Another name"\ncollection.meta = meta\n\n# Will fail\ncol_mgr.transaction(collection)\n# Will succeed\ncol_mgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// -> On device A:\nCollection collection = colMgr.fetch(collectionUid);\n\n\n// -> On device B:\nCollection collection = colMgr.fetch(collectionUid);\nItemMetadata meta = collection.getMeta();\nmeta.setName("New name");\ncollection.setMeta(meta);\n\ncolMgr.upload(collection);\n\n\n// -> On device A (using the previously saved collection)\nItemMetadata meta = collection.getMeta();\nmeta.setName("Another name");\ncollection.setMeta(meta);\n\n// Will fail\ncolMgr.transaction(collection);\n// Will succeed\ncolMgr.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'// -> On device A:\nval collection = colMgr.fetch(collectionUid)\n\n\n// -> On device B:\nval collection = colMgr.fetch(collectionUid)\nval meta = collection.getMeta()\nmeta.name = "New name"\ncollection.meta = meta\n\ncolMgr.upload(collection)\n\n\n// -> On device A (using the previously saved collection)\nval meta = collection.getMeta()\nmeta.name = "Another name"\ncollection.meta = meta\n\n// Will fail\ncolMgr.transaction(collection)\n// Will succeed\ncolMgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'// -> On device A:\nEtebaseCollection *col = etebase_collection_manager_fetch(col_mgr, col_uid, NULL);\n\n\n// -> On device B:\nEtebaseCollection *col = etebase_collection_manager_fetch(col_mgr, col_uid, NULL);\nEtebaseItemMetadata *col_meta = etebase_collection_get_meta(col);\netebase_collection_metadata_set_name(col_meta, "New name");\netebase_collection_set_meta(col, col_meta);\netebase_collection_metadata_destroy(col_meta);\n\netebase_collection_manager_upload(col_mgr, col, NULL);\n\netebase_collection_destroy(col);\n\n\n// -> On device A (using the previously saved collection)\nEtebaseItemMetadata *col_meta = etebase_collection_get_meta(col);\netebase_collection_metadata_set_name(col_meta, "Another name");\netebase_collection_set_meta(col, col_meta);\netebase_collection_metadata_destroy(col_meta);\n\n// Will fail\netebase_collection_manager_transaction(col_mgr, col, NULL);\n// Will succeed\netebase_collection_manager_upload(col_mgr, col, NULL);\n\netebase_collection_destroy(col);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// -> On device A:\nlet mut collection = collection_manager.fetch(collection_uid, None)?;\n\n\n// -> On device B:\nlet mut collection = collection_manager.fetch(collection_uid, None)?;\nlet mut meta = collection.meta()?;\nmeta.set_name("New name");\ncollection.set_meta(&meta)?;\n\ncollection_manager.upload(&collection, None)?;\n\n\n// -> On device A (using the previously saved collection)\nlet mut meta = collection.meta()?;\nmeta.set_name("Another name");\ncollection.set_meta(&meta)?;\n\n// Will fail\ncollection_manager.transaction(&collection, None)?;\n// Will succeed\ncollection_manager.upload(&collection, None)?;\n')))),(0,a.kt)("h3",{id:"using-stoken"},"Using ",(0,a.kt)("inlineCode",{parentName:"h3"},"stoken")),(0,a.kt)("p",null,"Transactions will only fail if the collection itself has changed, but will not fail if one of its items has changed. In some cases we want to have collection-wide consistency and want to make sure nothing has changed."),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// -> On device A:\nconst collection = await collectionManager.fetch(collectionUid);\nconst stoken = collection.stoken;\n\n\n// -> On device B:\nconst collection = await collectionManager.fetch(collectionUid);\nconst itemManager = collectionManager.getItemManager(collection);\n// Add a new item to tho collection (redacted for simplicity)\nawait itemManager.batch(...);\n\n\n// -> On device A (using the previously saved collection)\nconst stoken = collection.stoken;\nconst meta = collection.getMeta();\ncollection.setMeta({ ...meta, name: "Another name" });\n\n// Will both fail\nawait collectionManager.transaction(collection, { stoken });\nawait collectionManager.upload(collection, { stoken });\n\n// Will both succeed\nawait collectionManager.transaction(collection);\nawait collectionManager.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# -> On device A:\ncollection = col_mgr.fetch(collection_uid)\nstoken = collection.stoken\n\n# -> On device B:\ncollection = col_mgr.fetch(collection_uid)\nitem_mgr = col_mgr.get_item_manager(collection)\n# Add a new item to tho collection (redacted for simplicity)\nitem_mgr.batch(...)\n\n\n# -> On device A (using the previously saved collection)\nmeta = collection.meta\nmeta["name"] = "Another name"\ncollection.meta = meta\n\n# Will both fail\ncol_mgr.transaction(collection, FetchOptions().stoken(stoken))\ncol_mgr.upload(collection, FetchOptions().stoken(stoken))\n# Will both succeed\ncol_mgr.transaction(collection)\ncol_mgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// -> On device A:\nCollection collection = colMgr.fetch(collectionUid);\nString stoken = collection.stoken\n\n\n// -> On device B:\nCollection collection = colMgr.fetch(collectionUid);\nItemManager itemMgr = colMgr.getItemManager(collection);\n// Add a new item to tho collection (redacted for simplicity)\nitemMgr.batch(...)\n\n\n// -> On device A (using the previously saved collection)\nItemMetadata meta = collection.getMeta();\nmeta.setName("Another name");\ncollection.setMeta(meta);\n\n// Will both fail\ncolMgr.transaction(collection, new FetchOptions().stoken(stoken));\ncolMgr.upload(collection, new FetchOptions().stoken(stoken));\n// Will both succeed\ncolMgr.transaction(collection);\ncolMgr.upload(collection);\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'// -> On device A:\nval collection = colMgr.fetch(collectionUid)\nval stoken = collection.stoken\n\n\n// -> On device B:\nval collection = colMgr.fetch(collectionUid)\nval itemMgr = colMgr.getItemManager(collection)\n// Add a new item to tho collection (redacted for simplicity)\nitemMgr.batch(...)\n\n\n// -> On device A (using the previously saved collection)\nval meta = collection.getMeta()\nmeta.name = "Another name"\ncollection.meta = meta\n\n// Will both fail\ncolMgr.transaction(collection, FetchOptions().stoken(stoken))\ncolMgr.upload(collection, FetchOptions().stoken(stoken))\n// Will both succeed\ncolMgr.transaction(collection)\ncolMgr.upload(collection)\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'// -> On device A:\nEtebaseCollection *col = etebase_collection_manager_fetch(col_mgr, col_uid, NULL);\nconst char *stoken = etebase_collection_get_stoken(col);\n\n{\n    // -> On device B:\n    EtebaseCollection *col = etebase_collection_manager_fetch(col_mgr, col_uid, NULL);\n    EtebaseItemManager *item_mgr = etebase_collection_manager_get_item_manager(col_mgr, col);\n    etebase_item_manager_batch(...);\n\n    etebase_item_manager_destroy(item_mgr);\n    etebase_collection_destroy(col);\n}\n\n// -> On device A (using the previously saved collection)\nEtebaseItemMetadata *col_meta = etebase_collection_get_meta(col);\netebase_collection_metadata_set_name(col_meta, "Another name");\netebase_collection_set_meta(col, col_meta);\netebase_collection_metadata_destroy(col_meta);\n\nEtebaseFetchOptions *fetch_options = etebase_fetch_options_new();\netebase_fetch_options_set_stoken(fetch_options, stoken);\n\n// Will both fail\netebase_collection_manager_transaction(col_mgr, col, fetch_options);\netebase_collection_manager_upload(col_mgr, col, fetch_options);\n\netebase_fetch_options_destroy(fetch_options);\n\n// Will both succeed\netebase_collection_manager_transaction(col_mgr, col, NULL);\netebase_collection_manager_upload(col_mgr, col, NULL);\n\netebase_collection_destroy(col);\n'))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// -> On device A:\nlet mut collection = collection_manager.fetch(collection_uid, None)?;\nlet stoken = collection.stoken();\n\n\n// -> On device B:\nlet mut collection = collection_manager.fetch(collection_uid, None)?;\nlet item_manager = collection_manager.item_manager(&collection)?;\n// Add a new item to tho collection (redacted for simplicity)\nitem_manager.batch(..., None);\n\n\n// -> On device A (using the previously saved collection)\nlet mut meta = collection.meta()?;\nmeta.set_name("Another name");\ncollection.set_meta(&meta)?;\n\n// Will both fail\ncollection_manager.transaction(&collection, Some(&FetchOptions::new().stoken(stoken)))?;\ncollection_manager.upload(&collection, Some(&FetchOptions::new().stoken(stoken)))?;\n// Will both succeed\ncollection_manager.transaction(&collection, None)?;\ncollection_manager.upload(&collection, None)?;\n')))),(0,a.kt)("h2",{id:"binary-content"},"Binary content"),(0,a.kt)("p",null,"In the examples above content was always a string. However, content is actually a binary blob of data, not a string. Using it as a string is just a convenience."),(0,a.kt)("p",null,"Here is how you can control the formatting of the data:"),(0,a.kt)(c.Z,{mdxType:"CodeTabs"},(0,a.kt)(i.Z,{value:"js",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// default, returns a Promise<Uint8Array>\nawait collection.getContent();\n// tries to convert the binary data to a string and returns that\nawait collection.getContent(Etebase.OutputFormat.String);\n\n// Sets the content to a binary blob\nawait collection.setContent(Uint8Array.from([72, 101, 108, 108, 111]));\n// Sets the content to a string\nawait collection.setContent("Hello");\n'))),(0,a.kt)(i.Z,{value:"py",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# The Python API returns `bytes` by default\ncollection.content\n# Try decoding the binary data to a UTF-8 string\ncollection.content.decode()\n\n# Sets the content to some byte array\ncollection.content = b"Some bytes"\n# Set the content to a string\ncollection.content = "Some bytes".encode()\n'))),(0,a.kt)(i.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'// The Java API returns `byte[]` by default\ncollection.getContent();\n// Try decoding the binary data to a UTF-8 string and return that\ncollection.getContentString();\n\n// Sets the content to a binary blob\ncollection.setContent("Bla".getBytes("UTF-8"));\n// Sets the content to a string\ncollection.setContent("Hello");\n'))),(0,a.kt)(i.Z,{value:"kt",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'// The Java API returns `byte[]` by default\ncollection.content\n// Try decoding the binary data to a UTF-8 string and return that\ncollection.contentString\n\n// Sets the content to a binary blob\ncollection.content = "Bla".toByteArray()\n// Sets the content to a string\ncollection.content = "Hello"\n'))),(0,a.kt)(i.Z,{value:"c",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"// The C API always works on binary data,\n// This means content is *not* NULL terminated!\n\n// It's generally fastest to just try to get the content into a buffer\n// if we think it's likely to be under a certain size.\nchar tmp[500];\nintptr_t len = etebase_collection_get_content(col, tmp, sizeof(tmp));\n\nif (len < 0) {\n    // Error\n} else if (len > sizeof(tmp)) {\n    // This means we should allocate a buffer of size len to fetch into\n    char *tmp2 = malloc(len);\n    etebase_collection_get_content(col, tmp2, len);\n    // Do something with tmp2\n    free(tmp2);\n}\n\n// As said above, content is not null terminated.\n// To get the content as a null terminated string:\nchar tmp[500];\nintptr_t len = etebase_collection_get_content(col, tmp, sizeof(tmp));\n\nif (len < 0) {\n    // Error\n} else {\n    tmp[len] = 0;\n}\n"))),(0,a.kt)(i.Z,{value:"rs",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// The rust API returns `Vec<u8>` by default\ncollection.content()?;\n// Try decoding the binary data to a UTF-8 string and return that\nString::from_utf8(collection.content()?);\n\n// Sets the content to a binary blob\ncollection.set_content(&vec![0, 1, 2])?;\n// Sets the content to a string\ncollection.set_content("Hello".as_bytes())?;\n')))))}_.isMDXComponent=!0}}]);